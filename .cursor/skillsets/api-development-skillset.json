{
  "name": "API Development Specialist",
  "domain": "rest-api",
  "version": "1.0",
  "expertise": [
    "express-routing",
    "error-handling",
    "middleware",
    "cors-configuration",
    "api-security"
  ],
  "technology_stack": {
    "framework": "Express 5.1.0",
    "runtime": "Node.js",
    "module_system": "CommonJS (require/module.exports)",
    "middleware": [
      "express.json() - JSON body parsing",
      "cors() - CORS handling"
    ]
  },
  "api_design_patterns": {
    "restful_conventions": {
      "resources": [
        "/api/sessions - Session collection",
        "/api/history - Chat history collection",
        "/api/models - Model listing",
        "/api/keys - API key management"
      ],
      "http_methods": {
        "GET": "Retrieve resource(s)",
        "POST": "Create resource or trigger action",
        "PUT": "Update existing resource",
        "DELETE": "Remove resource"
      },
      "status_codes": {
        "200": "Success with body",
        "204": "Success without body (DELETE)",
        "400": "Bad request (validation error)",
        "404": "Resource not found",
        "500": "Internal server error"
      }
    },
    "error_handling": {
      "pattern": "try-catch with descriptive error messages",
      "code_template": "app.post('/api/endpoint', async (req, res) => {\n  try {\n    // Process request\n    const result = await someOperation();\n    res.json(result);\n  } catch (error) {\n    console.error('[Endpoint] Error:', error);\n    res.status(500).json({ \n      error: 'Operation failed', \n      details: error.message \n    });\n  }\n});",
      "best_practices": [
        "Log full error with context",
        "Return sanitized error to client (no stack traces in production)",
        "Use specific status codes",
        "Include error field in JSON response"
      ]
    },
    "validation": {
      "pattern": "Early validation with 400 responses",
      "code_template": "if (!req.body.name || typeof req.body.name !== 'string') {\n  return res.status(400).json({ error: 'Invalid or missing name' });\n}",
      "validation_points": [
        "Required fields presence",
        "Type checking",
        "Range/length limits",
        "Format validation (email, UUID, etc.)"
      ]
    },
    "async_await": {
      "pattern": "Consistent async/await for all async operations",
      "note": "All route handlers use async (req, res) => {...}",
      "error_propagation": "Errors bubble to catch blocks or global error handler"
    }
  },
  "middleware_patterns": {
    "cors_configuration": {
      "current": "app.use(cors()) - Wide open, all origins allowed",
      "location": "server.js:726",
      "security_note": "INSECURE for production",
      "recommended_improvement": "app.use(cors({\n  origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',\n  credentials: true\n}))"
    },
    "json_body_parsing": {
      "middleware": "express.json()",
      "location": "server.js:727",
      "default_limit": "100kb",
      "recommendation": "Increase for attachments: express.json({ limit: '10mb' })"
    },
    "streaming_guards": {
      "purpose": "Disable timeouts for SSE routes",
      "code_template": "function applyStreamingGuards(req, res, label) {\n  req.setTimeout(0);\n  res.setTimeout(0);\n  if (res.socket) {\n    res.socket.setTimeout(0);\n    res.socket.setKeepAlive(true);\n  }\n}",
      "location": "server.js:607-684",
      "applied_to": [
        "/api/generate (stream=true)",
        "/api/chat/stream"
      ]
    },
    "api_key_authentication": {
      "description": "Optional authentication via API key",
      "code_template": "function optionalApiKeyAuth(req, res, next) {\n  const apiKey = req.headers['x-api-key'] || req.headers['authorization']?.replace('Bearer ', '');\n  \n  if (!apiKey) {\n    return next(); // Optional auth, continue without key\n  }\n  \n  const keyHash = crypto.createHash('sha256').update(apiKey).digest('hex');\n  const validKey = Object.values(apiKeyStore.keys).find(k => k.hash === keyHash);\n  \n  if (!validKey) {\n    return res.status(401).json({ error: 'Invalid API key' });\n  }\n  \n  validKey.lastUsedAt = new Date().toISOString();\n  persistApiKeys();\n  next();\n}",
      "location": "server.js:380-457",
      "headers": [
        "X-API-Key: <key>",
        "Authorization: Bearer <key>"
      ]
    }
  },
  "endpoint_catalog": {
    "chat_endpoints": {
      "POST /api/chat": {
        "purpose": "Non-streaming chat",
        "location": "server.js:1207-1372",
        "auth": "Optional API key",
        "timeout": "OLLAMA_GENERATION_TIMEOUT_MS (600s default)"
      },
      "POST /api/chat/stream": {
        "purpose": "Streaming chat with SSE",
        "location": "server.js:1207-1372",
        "auth": "Optional API key",
        "timeout": "Disabled (streaming guards applied)"
      }
    },
    "ollama_proxy": {
      "POST /api/generate": {
        "purpose": "Direct Ollama generation proxy",
        "location": "server.js:1059-1205",
        "supports_streaming": true,
        "normalization": "normalizeGenerateInputs() applied"
      },
      "GET /api/models": {
        "purpose": "List available models",
        "location": "server.js:941-987",
        "ollama_endpoint": "/api/tags"
      }
    },
    "session_management": {
      "GET /api/sessions": "List all sessions",
      "GET /api/sessions/:id": "Get session details",
      "POST /api/sessions": "Create session",
      "PUT /api/sessions/:id": "Update session",
      "DELETE /api/sessions/:id": "Delete session",
      "POST /api/sessions/:id/select": "Set active session"
    },
    "history_management": {
      "GET /api/history": "Get session history",
      "DELETE /api/history": "Clear session history",
      "POST /api/history/entry": "Manually add history entry"
    },
    "settings": {
      "GET /api/settings": "Get current settings + presets",
      "POST /api/settings": "Update runtime settings"
    },
    "api_keys": {
      "GET /api/keys": "List API keys (secrets masked)",
      "POST /api/keys": "Generate new API key",
      "DELETE /api/keys/:id": "Revoke API key"
    },
    "utility": {
      "GET /health": "Health check + status info",
      "POST /api/proxy": "Generic HTTP proxy"
    }
  },
  "common_mistakes": [
    {
      "mistake": "Not validating request body before processing",
      "impact": "Unexpected errors, null pointer exceptions",
      "fix": "Validate required fields early, return 400 on invalid input",
      "example": "if (!req.body.message) return res.status(400).json({ error: 'Missing message' });"
    },
    {
      "mistake": "Forgetting to handle async errors",
      "impact": "Unhandled promise rejections, server crashes",
      "fix": "Wrap async routes in try-catch or use express-async-errors",
      "pattern": "app.post('/endpoint', async (req, res) => {\n  try { ... } catch (error) { ... }\n});"
    },
    {
      "mistake": "Returning 200 on errors",
      "impact": "Clients can't distinguish success from failure",
      "fix": "Use appropriate status codes (400, 404, 500)",
      "best_practice": "res.status(404).json({ error: 'Not found' })"
    },
    {
      "mistake": "Not setting timeouts to 0 for streaming",
      "impact": "Streams abort at ~2 minutes",
      "fix": "Call applyStreamingGuards(req, res) for SSE routes",
      "location": "server.js:607-684"
    },
    {
      "mistake": "Exposing sensitive data in error messages",
      "impact": "Information disclosure, security risk",
      "fix": "Log full error server-side, return generic message to client",
      "example": "console.error(error); res.status(500).json({ error: 'Internal error' });"
    },
    {
      "mistake": "Not sanitizing user input",
      "impact": "Potential injection attacks (though low risk with JSON-only storage)",
      "fix": "Use normalization functions, enforce limits",
      "examples": [
        "normalizeSession()",
        "sanitizeAttachments()",
        "normalizeGenerateInputs()"
      ]
    }
  ],
  "security_best_practices": {
    "current_security_posture": {
      "strengths": [
        "API key hashing with SHA-256",
        "Input sanitization via normalization functions",
        "No SQL/database injection risk (filesystem only)"
      ],
      "weaknesses": [
        "CORS wide open (allows all origins)",
        "No rate limiting",
        "No request size limits (beyond Express default 100kb)",
        "API keys don't expire",
        "No CSRF protection"
      ]
    },
    "recommended_improvements": {
      "cors": "Whitelist specific origins via ALLOWED_ORIGINS env var",
      "rate_limiting": "Use express-rate-limit middleware",
      "request_size": "Set explicit limits: express.json({ limit: '10mb' })",
      "api_key_expiration": "Add expiresAt field, check on auth",
      "csrf": "Add CSRF tokens for state-changing operations",
      "helmet": "Use helmet middleware for security headers"
    }
  },
  "performance_optimization": {
    "caching": {
      "current": "No caching implemented",
      "opportunities": [
        "Cache GET /api/models response (TTL: 5 minutes)",
        "Cache instruction presets (already in-memory)",
        "ETag support for sessions"
      ]
    },
    "compression": {
      "recommendation": "Use compression middleware",
      "setup": "const compression = require('compression'); app.use(compression());"
    },
    "connection_pooling": {
      "note": "Ollama uses fetch (HTTP/1.1 keep-alive by default)",
      "consideration": "HTTP/2 support for Ollama if available"
    }
  },
  "testing": {
    "verification_script": "scripts/verify.js",
    "curl_examples": "scripts/curl-examples.sh",
    "test_coverage": [
      "Non-streaming generation",
      "Streaming generation",
      "Session CRUD",
      "History management",
      "API key authentication"
    ],
    "manual_testing": [
      "Postman collection recommended",
      "Test streaming with curl -N flag",
      "Verify CORS with different origins"
    ]
  },
  "logging_and_monitoring": {
    "current_logging": {
      "pattern": "console.log() and console.error()",
      "location": "Throughout server.js",
      "format": "[Label] Message"
    },
    "recommended_improvements": {
      "structured_logging": "Use winston or pino for JSON logs",
      "log_levels": "DEBUG, INFO, WARN, ERROR",
      "request_logging": "morgan middleware for HTTP request logs",
      "metrics": "Track request duration, error rates, Ollama response times"
    }
  },
  "deployment_considerations": {
    "environment_variables": "Use .env file with dotenv package",
    "process_management": "Use PM2 or systemd for production",
    "reverse_proxy": "Nginx or Caddy for HTTPS termination",
    "health_checks": "GET /health for monitoring systems",
    "graceful_shutdown": "Handle SIGTERM to close Ollama connections"
  }
}
