{
  "name": "Frontend State Management Specialist",
  "domain": "client-side-architecture",
  "version": "1.0",
  "expertise": [
    "vanilla-javascript-spa",
    "localstorage-persistence",
    "event-driven-architecture",
    "template-rendering",
    "state-synchronization"
  ],
  "technology_stack": {
    "framework": "Vanilla JavaScript (no framework)",
    "architecture": "Single Page Application (SPA)",
    "module_system": "None (global scope)",
    "templating": "HTML <template> elements with cloneNode()",
    "storage": "localStorage API",
    "http": "Fetch API",
    "events": "CustomEvent for inter-component communication"
  },
  "state_structure": {
    "global_state": {
      "location": "window.appState",
      "schema": {
        "settings": {
          "model": "string",
          "apiEndpoint": "string",
          "theme": "string",
          "systemInstructions": "string",
          "maxHistory": "number",
          "backendBaseUrl": "string"
        },
        "chat": "array of messages",
        "sessions": "array of Session objects",
        "activeSessionId": "string",
        "pages": "array of { id, name, sessionId }",
        "thinkingEnabled": "boolean",
        "thinkingModel": "string",
        "availableModels": "array",
        "instructionPresets": "array"
      },
      "location": "public/app.js"
    },
    "localStorage_keys": {
      "history": "Array of chat messages",
      "settings": "Settings object",
      "pages": "Array of page objects",
      "thinking": "Thinking mode preferences",
      "activeSession": "Current session ID",
      "instructionPresets": "Cached presets"
    }
  },
  "patterns": {
    "event_driven_updates": {
      "description": "Use CustomEvent for state change notifications",
      "code_template": "function notifySettingsSubscribers() {\n  window.appState = state;\n  window.dispatchEvent(new CustomEvent('ollama-settings', { \n    detail: state.settings \n  }));\n  window.dispatchEvent(new CustomEvent('ollama-state', { \n    detail: state \n  }));\n}\n\n// Listeners\nwindow.addEventListener('ollama-settings', (event) => {\n  const settings = event.detail;\n  // Update UI\n});",
      "location": "public/app.js",
      "events": [
        "ollama-settings - Settings changed",
        "ollama-state - Full state updated"
      ],
      "benefits": [
        "Decoupled components",
        "Reactive UI updates",
        "Easy to add new listeners"
      ]
    },
    "localstorage_persistence": {
      "description": "Sync state to localStorage for persistence across sessions",
      "code_template": "function persistSettings() {\n  localStorage.setItem('settings', JSON.stringify(state.settings));\n}\n\nfunction loadSettings() {\n  const saved = localStorage.getItem('settings');\n  if (saved) {\n    state.settings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };\n  }\n}",
      "location": "public/app.js",
      "triggers": [
        "Settings change",
        "Chat message sent/received",
        "Session switch",
        "Page create/delete"
      ],
      "best_practices": [
        "Merge with defaults to handle missing keys",
        "Validate data before loading",
        "Handle JSON.parse errors gracefully"
      ]
    },
    "template_rendering": {
      "description": "Clone <template> elements for dynamic content",
      "code_template": "const template = document.getElementById('message-template');\nconst clone = template.content.cloneNode(true);\nclone.querySelector('.message-text').textContent = message;\ncontainer.appendChild(clone);",
      "location": "public/index.html + public/app.js",
      "advantages": [
        "Declarative HTML structure",
        "No string concatenation/XSS risk",
        "Browser-native, fast"
      ],
      "templates": [
        "#message-template - Chat message bubble",
        "#session-template - Session list item",
        "#preset-template - Preset selector option"
      ]
    },
    "dual_sync_pattern": {
      "description": "Sync state between server and localStorage",
      "flow": [
        "On load: Fetch from server → Merge with localStorage → Update state",
        "On change: Update state → Save to localStorage → POST to server",
        "Periodic sync: Every 5 minutes, sync localStorage to server",
        "On unload: Final sync to server"
      ],
      "code_template": "async function syncToServer() {\n  const data = {\n    sessions: state.sessions,\n    activeSessionId: state.activeSessionId,\n    history: state.chat\n  };\n  await fetch('/api/sync/data', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(data)\n  });\n}",
      "location": "public/app.js:1917-2032",
      "note": "Labeled 'cloud sync' but currently just server persistence"
    },
    "optimistic_updates": {
      "description": "Update UI immediately, sync to server async",
      "pattern": "User action → Update state → Render UI → POST to server → Handle errors",
      "example": "function sendMessage(message) {\n  // Immediately show user message\n  addMessageToUI({ role: 'user', content: message });\n  \n  // Send to server async\n  fetch('/api/chat', { ... })\n    .then(response => addMessageToUI({ role: 'assistant', content: response }))\n    .catch(error => showError(error));\n}",
      "benefits": [
        "Instant feedback",
        "Better perceived performance",
        "Offline-first capability"
      ]
    },
    "connection_status_tracking": {
      "description": "Monitor server connectivity and show status",
      "code_template": "async function fetchJson(url, options) {\n  try {\n    const response = await fetch(url, options);\n    updateConnectionStatus('online');\n    return await response.json();\n  } catch (error) {\n    updateConnectionStatus('offline');\n    throw error;\n  }\n}\n\nfunction updateConnectionStatus(status) {\n  const badge = document.getElementById('connection-status');\n  badge.className = status === 'online' ? 'online' : 'offline';\n  badge.textContent = status;\n}",
      "location": "public/app.js",
      "triggers": [
        "Fetch success → online",
        "Fetch error → offline",
        "Health check interval"
      ]
    }
  },
  "common_mistakes": [
    {
      "mistake": "Directly mutating state without triggering updates",
      "impact": "UI doesn't reflect state changes",
      "fix": "Always call notifySubscribers() after state mutation",
      "example": "state.settings.model = 'new-model';\nnotifySettingsSubscribers();"
    },
    {
      "mistake": "Not handling localStorage quota exceeded errors",
      "impact": "App crashes on localStorage write",
      "fix": "Wrap setItem in try-catch, handle QuotaExceededError",
      "code": "try {\n  localStorage.setItem(key, value);\n} catch (e) {\n  if (e.name === 'QuotaExceededError') {\n    // Clear old data or notify user\n  }\n}"
    },
    {
      "mistake": "Assuming localStorage always has valid JSON",
      "impact": "JSON.parse() errors on corrupted data",
      "fix": "Always validate and provide defaults",
      "pattern": "try {\n  const data = JSON.parse(localStorage.getItem(key));\n  return { ...defaults, ...data };\n} catch {\n  return defaults;\n}"
    },
    {
      "mistake": "Not escaping user content before rendering",
      "impact": "XSS vulnerabilities",
      "fix": "Use textContent or escapeHtml() function",
      "location": "public/app.js has escapeHtml() utility"
    },
    {
      "mistake": "Race conditions on concurrent API calls",
      "impact": "Stale data overwrites fresh data",
      "fix": "Track request IDs or use request cancellation",
      "example": "let currentRequestId = 0;\nasync function fetchData() {\n  const requestId = ++currentRequestId;\n  const data = await fetch(...);\n  if (requestId === currentRequestId) {\n    // Only update if this is the latest request\n    updateState(data);\n  }\n}"
    },
    {
      "mistake": "Not cleaning up event listeners",
      "impact": "Memory leaks, duplicate handlers",
      "fix": "Remove listeners on component destroy",
      "pattern": "const handler = (e) => { ... };\nwindow.addEventListener('event', handler);\n// Later:\nwindow.removeEventListener('event', handler);"
    }
  ],
  "performance_optimization": {
    "debouncing": {
      "description": "Debounce expensive operations like sync",
      "code_template": "function debounce(fn, delay) {\n  let timer;\n  return function(...args) {\n    clearTimeout(timer);\n    timer = setTimeout(() => fn(...args), delay);\n  };\n}\n\nconst debouncedSync = debounce(syncToServer, 1000);",
      "use_cases": [
        "Auto-save on input change",
        "Search-as-you-type",
        "Window resize handlers"
      ]
    },
    "lazy_rendering": {
      "description": "Only render visible elements",
      "recommendation": "Implement virtual scrolling for long chat history",
      "benefit": "Better performance with 1000+ messages"
    },
    "request_batching": {
      "description": "Batch multiple state changes into single server request",
      "pattern": "Accumulate changes → Debounce → Send batch update",
      "example": "Instead of 10 individual session updates, batch into one PUT /api/sessions"
    }
  },
  "mobile_optimization": {
    "viewport_meta": {
      "tag": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, viewport-fit=cover\">",
      "purpose": "Responsive layout, notch support",
      "location": "public/index.html"
    },
    "touch_friendly_ui": {
      "button_height": "min-height: 44px (iOS recommendation)",
      "tap_targets": "Minimum 44x44px",
      "scrolling": "-webkit-overflow-scrolling: touch for smooth scroll"
    },
    "media_queries": {
      "mobile": "@media (max-width: 768px)",
      "tablet": "@media (max-width: 1024px)",
      "location": "public/styles.css"
    }
  },
  "testing": {
    "manual_testing": [
      "Open DevTools → Application → Local Storage",
      "Verify state persistence across refresh",
      "Test offline mode (disable network in DevTools)",
      "Verify event firing with console.log in listeners"
    ],
    "automated_testing": {
      "recommendation": "Use Puppeteer for E2E tests",
      "test_cases": [
        "State persists across page reload",
        "Settings changes trigger UI update",
        "Session switch loads correct history",
        "Offline mode shows connection status"
      ]
    },
    "browser_compatibility": {
      "target": "Modern browsers (Chrome 90+, Firefox 88+, Safari 14+)",
      "required_features": [
        "Fetch API",
        "localStorage",
        "CustomEvent",
        "Template elements",
        "ES6+ (arrow functions, async/await)"
      ]
    }
  },
  "debugging": {
    "state_inspection": {
      "console_command": "window.appState",
      "description": "Inspect current state in DevTools console"
    },
    "event_logging": {
      "pattern": "window.addEventListener('ollama-state', (e) => console.log('State updated:', e.detail));",
      "benefit": "Track state changes in real-time"
    },
    "localstorage_inspection": {
      "devtools": "Application → Local Storage → http://localhost:3000",
      "clear_storage": "localStorage.clear() in console to reset"
    }
  },
  "future_enhancements": {
    "state_management_library": "Consider Zustand or Jotai for complex state",
    "offline_first": "Service workers for true offline mode",
    "real_time_sync": "WebSocket for multi-tab synchronization",
    "undo_redo": "Command pattern for history management",
    "state_versioning": "Migrate localStorage schema on app updates"
  }
}
